#!/usr/bin/env bash
set -eo pipefail
APP="$1"; IMAGE="app/$APP"
APP_ROOT="$DOKKU_ROOT/$APP"
APP_PS="$APP_ROOT/PS"

# Check if app has a PS file
# if not default to "web=1"
if [ ! -s "$APP_PS" ]; then
  echo "web=1" > $APP_PS
fi

function ps_each(){
  CMD="$1"; APP="$2"; NAME="$3"; NUM="$4"
  for ((i=1; i<=$NUM; i++)); do
    sudo $CMD dokku-ps APP=$APP NAME=$NAME SEQ=$i > /dev/null || {
      # echo " -- failed with exit $? --"
      true # don't skip the rest if one was already stopped/started
    }
  done
}

while read line; do
  NAME=${line%%=*}
  NUM=${line#*=}

  # stop any running processes first otherwise
  # `docker kill` will just make it restart
  ps_each stop $APP $NAME $NUM || true

  # create a container for each process
  for ((i=1; i<=$NUM; i++)); do
    # remove container if already exists
    # outputs the id if existed, nothing otherwise
    docker kill "$APP.$NAME.$i" > /dev/null || true
    docker rm "$APP.$NAME.$i" > /dev/null || true

    # create a named container using `docker run`
    id=$(docker run -d -name "$APP.$NAME.$i" -p 5000 -e PORT=5000 $IMAGE /start $NAME)

    # TODO make sure it started?

    # stop the container again (to be started using upstart instead)
    docker stop $id > /dev/null # outputs the id if existed, nothing otherwise
  done

  echo "-----> Starting $NAME"
  ps_each start $APP $NAME $NUM
  echo "       $NUM processes up and running"

  # give the apps some time to boot before moving on to nginx
  # TODO figure out a better way to see when it has started/is listening
  # while curl -s -I localhost:`docker port $APP.$NAME.1 5000` ?
  # this is mostly required for really slow apps like anything on ruby...
  sleep 4
done < $APP_PS